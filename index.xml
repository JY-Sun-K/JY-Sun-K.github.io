<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pEnguin</title>
    <link>https://jy-sun-k.github.io/</link>
    <description>Recent content on pEnguin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 08 Jun 2021 22:37:57 +0800</lastBuildDate>
    
	<atom:link href="https://jy-sun-k.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>分布式缓存三</title>
      <link>https://jy-sun-k.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8Fredis/</link>
      <pubDate>Tue, 08 Jun 2021 22:37:57 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8Fredis/</guid>
      <description>Redis 基本原理 Redis 特性 Redis 性能很高，单线程压测可以达到 10~11w 的 QPS。 Redis 所有数据的读写操作，都在内存中进行，但也可以将所有数据进行落盘做持久化。Redis 提供了 2 种持久化方式。 快照方式，将某时刻所有数据都写入硬盘</description>
    </item>
    
    <item>
      <title>Redis 一</title>
      <link>https://jy-sun-k.github.io/posts/go-go-go/</link>
      <pubDate>Tue, 08 Jun 2021 22:32:03 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/go-go-go/</guid>
      <description>redis慢查询 生命周期 ps: 慢查询发生在第三阶段 客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素 slowlog-max-log 先进先出队列 固定长度 保存在内存内 slowlog-log-slower-than 慢查询阈值 单位微秒 slowlog-log-slower-th</description>
    </item>
    
    <item>
      <title>MongoDB 一</title>
      <link>https://jy-sun-k.github.io/posts/mongo/</link>
      <pubDate>Tue, 08 Jun 2021 22:25:16 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/mongo/</guid>
      <description>mongoDB 与mysql比较 mysql MongoDB database database table collection row document(bson) column field index index table joins $lookup primary key _id group by aggregation pipeline 用法 列举数据库： show databases 选择数据库： use my_db tips:数据库无需创建，只是一个命名空间 列举数据表： show collections 建立数据表： db.createCollection(&amp;#34;my_collection&amp;#34;) tips: 数据表是schema free ,无需</description>
    </item>
    
    <item>
      <title>分布式缓存二</title>
      <link>https://jy-sun-k.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F2/</link>
      <pubDate>Wed, 26 May 2021 16:10:24 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F2/</guid>
      <description>缓存失效、穿透和雪崩问题怎么处理？ 缓存失效 问题描述 缓存第一个经典问题是缓存失效。上一课时讲到，服务系统查数据，首先会查缓存，如果缓存数据不存在，就进一步查 DB，最后查到数据后回种到缓存并返回。缓存的性</description>
    </item>
    
    <item>
      <title>Go基础</title>
      <link>https://jy-sun-k.github.io/posts/go%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 26 May 2021 00:07:28 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/go%E5%9F%BA%E7%A1%80/</guid>
      <description>go基础 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。 Golang 是一种编译型语言。源代码会编译为二进制机器码。 使用 %T 格式说明符（Format Specifier），可</description>
    </item>
    
    <item>
      <title>Go并发tips</title>
      <link>https://jy-sun-k.github.io/posts/go%E5%B9%B6%E5%8F%91tips/</link>
      <pubDate>Tue, 25 May 2021 23:48:02 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/go%E5%B9%B6%E5%8F%91tips/</guid>
      <description>Mutex 互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。 临界区就是一个被共享的资源，或者说是一个整体的一组共享资源 使用互斥锁，限定临界区只能同时由一个线程持有。 同步原语的适用场景： 共</description>
    </item>
    
    <item>
      <title>分布式缓存一</title>
      <link>https://jy-sun-k.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F1/</link>
      <pubDate>Tue, 25 May 2021 22:15:28 +0800</pubDate>
      
      <guid>https://jy-sun-k.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F1/</guid>
      <description>业务数据访问性能太低怎么办？ 缓存的定义 缓存最初的含义，是指用于加速 CPU 数据交换的 RAM，即随机存取存储器，通常这种存储器使用更昂贵但快速的静态 RAM（SRAM）技术，用以对 DRAM进 行加速。这是一个狭义</description>
    </item>
    
  </channel>
</rss>